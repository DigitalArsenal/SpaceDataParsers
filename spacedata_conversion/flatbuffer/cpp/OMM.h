// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IDLDOCUMENT_H_
#define FLATBUFFERS_GENERATED_IDLDOCUMENT_H_

#include "flatbuffers/flatbuffers.h"

struct OMM;
struct OMMBuilder;

struct MPE;
struct MPEBuilder;

struct OMMCOLLECTION;
struct OMMCOLLECTIONBuilder;

enum referenceFrame {
  /// Earth Mean Equator and Equinox of J2000
  referenceFrame_EME2000 = 0,
  ///  Geocentric Celestial Reference Frame
  referenceFrame_GCRF = 1,
  /// Greenwich Rotating Coordinates
  referenceFrame_GRC = 2,
  /// International Celestial Reference Frame
  referenceFrame_ICRF = 3,
  /// International Terrestrial Reference Frame 2000
  referenceFrame_ITRF2000 = 4,
  /// International Terrestrial Reference Frame 1993
  referenceFrame_ITRF93 = 5,
  /// International Terrestrial Reference Frame 1997
  referenceFrame_ITRF97 = 6,
  /// Mars Centered Inertial
  referenceFrame_MCI = 7,
  /// True of Date, Rotating
  referenceFrame_TDR = 8,
  /// True Equator Mean Equinox
  referenceFrame_TEME = 9,
  /// True of Date
  referenceFrame_TOD = 10,
  referenceFrame_MIN = referenceFrame_EME2000,
  referenceFrame_MAX = referenceFrame_TOD
};

inline const referenceFrame (&EnumValuesreferenceFrame())[11] {
  static const referenceFrame values[] = {
    referenceFrame_EME2000,
    referenceFrame_GCRF,
    referenceFrame_GRC,
    referenceFrame_ICRF,
    referenceFrame_ITRF2000,
    referenceFrame_ITRF93,
    referenceFrame_ITRF97,
    referenceFrame_MCI,
    referenceFrame_TDR,
    referenceFrame_TEME,
    referenceFrame_TOD
  };
  return values;
}

inline const char * const *EnumNamesreferenceFrame() {
  static const char * const names[12] = {
    "EME2000",
    "GCRF",
    "GRC",
    "ICRF",
    "ITRF2000",
    "ITRF93",
    "ITRF97",
    "MCI",
    "TDR",
    "TEME",
    "TOD",
    nullptr
  };
  return names;
}

inline const char *EnumNamereferenceFrame(referenceFrame e) {
  if (flatbuffers::IsOutRange(e, referenceFrame_EME2000, referenceFrame_TOD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesreferenceFrame()[index];
}

enum ephemerisType {
  /// Simplified General Perturbation Model 
  ephemerisType_SGP = 0,
  /// Simplified General Perturbation Model  4
  ephemerisType_SGP4 = 1,
  /// Simplified Deep Space Perturbation Model 4 
  ephemerisType_SDP4 = 2,
  /// Simplified General Perturbation Model 8
  ephemerisType_SGP8 = 3,
  /// Simplified Deep Space Perturbation Model 8
  ephemerisType_SDP8 = 4,
  ephemerisType_MIN = ephemerisType_SGP,
  ephemerisType_MAX = ephemerisType_SDP8
};

inline const ephemerisType (&EnumValuesephemerisType())[5] {
  static const ephemerisType values[] = {
    ephemerisType_SGP,
    ephemerisType_SGP4,
    ephemerisType_SDP4,
    ephemerisType_SGP8,
    ephemerisType_SDP8
  };
  return values;
}

inline const char * const *EnumNamesephemerisType() {
  static const char * const names[6] = {
    "SGP",
    "SGP4",
    "SDP4",
    "SGP8",
    "SDP8",
    nullptr
  };
  return names;
}

inline const char *EnumNameephemerisType(ephemerisType e) {
  if (flatbuffers::IsOutRange(e, ephemerisType_SGP, ephemerisType_SDP8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesephemerisType()[index];
}

enum timeSystem {
  /// Greenwich Mean Sidereal Time
  timeSystem_GMST = 0,
  /// Global Positioning System
  timeSystem_GPS = 1,
  /// Mission Elapsed Time
  timeSystem_MET = 2,
  /// Mission Relative Time
  timeSystem_MRT = 3,
  /// Spacecraft Clock (receiver) (requires rules for interpretation in ICD)
  timeSystem_SCLK = 4,
  /// International Atomic Time
  timeSystem_TAI = 5,
  /// Barycentric Coordinate Time
  timeSystem_TCB = 6,
  /// Barycentric Dynamical Time
  timeSystem_TDB = 7,
  /// Geocentric Coordinate Time
  timeSystem_TCG = 8,
  /// Terrestrial Time
  timeSystem_TT = 9,
  /// Universal Time
  timeSystem_UT1 = 10,
  /// Coordinated Universal Time 
  timeSystem_UTC = 11,
  timeSystem_MIN = timeSystem_GMST,
  timeSystem_MAX = timeSystem_UTC
};

inline const timeSystem (&EnumValuestimeSystem())[12] {
  static const timeSystem values[] = {
    timeSystem_GMST,
    timeSystem_GPS,
    timeSystem_MET,
    timeSystem_MRT,
    timeSystem_SCLK,
    timeSystem_TAI,
    timeSystem_TCB,
    timeSystem_TDB,
    timeSystem_TCG,
    timeSystem_TT,
    timeSystem_UT1,
    timeSystem_UTC
  };
  return values;
}

inline const char * const *EnumNamestimeSystem() {
  static const char * const names[13] = {
    "GMST",
    "GPS",
    "MET",
    "MRT",
    "SCLK",
    "TAI",
    "TCB",
    "TDB",
    "TCG",
    "TT",
    "UT1",
    "UTC",
    nullptr
  };
  return names;
}

inline const char *EnumNametimeSystem(timeSystem e) {
  if (flatbuffers::IsOutRange(e, timeSystem_GMST, timeSystem_UTC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamestimeSystem()[index];
}

enum meanElementTheory {
  /// Simplified General Perturbation Model  4
  meanElementTheory_SGP4 = 0,
  /// Draper Semi-analytical Satellite Theory
  meanElementTheory_DSST = 1,
  /// Universal Semianalytical Method
  meanElementTheory_USM = 2,
  meanElementTheory_MIN = meanElementTheory_SGP4,
  meanElementTheory_MAX = meanElementTheory_USM
};

inline const meanElementTheory (&EnumValuesmeanElementTheory())[3] {
  static const meanElementTheory values[] = {
    meanElementTheory_SGP4,
    meanElementTheory_DSST,
    meanElementTheory_USM
  };
  return values;
}

inline const char * const *EnumNamesmeanElementTheory() {
  static const char * const names[4] = {
    "SGP4",
    "DSST",
    "USM",
    nullptr
  };
  return names;
}

inline const char *EnumNamemeanElementTheory(meanElementTheory e) {
  if (flatbuffers::IsOutRange(e, meanElementTheory_SGP4, meanElementTheory_USM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmeanElementTheory()[index];
}

enum manCovRefFrame {
  manCovRefFrame_RSW = 0,
  manCovRefFrame_RTN = 1,
  manCovRefFrame_TNW = 2,
  manCovRefFrame_MIN = manCovRefFrame_RSW,
  manCovRefFrame_MAX = manCovRefFrame_TNW
};

inline const manCovRefFrame (&EnumValuesmanCovRefFrame())[3] {
  static const manCovRefFrame values[] = {
    manCovRefFrame_RSW,
    manCovRefFrame_RTN,
    manCovRefFrame_TNW
  };
  return values;
}

inline const char * const *EnumNamesmanCovRefFrame() {
  static const char * const names[4] = {
    "RSW",
    "RTN",
    "TNW",
    nullptr
  };
  return names;
}

inline const char *EnumNamemanCovRefFrame(manCovRefFrame e) {
  if (flatbuffers::IsOutRange(e, manCovRefFrame_RSW, manCovRefFrame_TNW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmanCovRefFrame()[index];
}

struct OMM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OMMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CCSDS_OMM_VERS = 4,
    VT_CREATION_DATE = 6,
    VT_ORIGINATOR = 8,
    VT_OBJECT_NAME = 10,
    VT_OBJECT_ID = 12,
    VT_CENTER_NAME = 14,
    VT_REF_FRAME = 16,
    VT_REF_FRAME_EPOCH = 18,
    VT_TIME_SYSTEM = 20,
    VT_MEAN_ELEMENT_THEORY = 22,
    VT_COMMENT = 24,
    VT_EPOCH = 26,
    VT_SEMI_MAJOR_AXIS = 28,
    VT_MEAN_MOTION = 30,
    VT_ECCENTRICITY = 32,
    VT_INCLINATION = 34,
    VT_RA_OF_ASC_NODE = 36,
    VT_ARG_OF_PERICENTER = 38,
    VT_MEAN_ANOMALY = 40,
    VT_GM = 42,
    VT_MASS = 44,
    VT_SOLAR_RAD_AREA = 46,
    VT_SOLAR_RAD_COEFF = 48,
    VT_DRAG_AREA = 50,
    VT_DRAG_COEFF = 52,
    VT_EPHEMERIS_TYPE = 54,
    VT_CLASSIFICATION_TYPE = 56,
    VT_NORAD_CAT_ID = 58,
    VT_ELEMENT_SET_NO = 60,
    VT_REV_AT_EPOCH = 62,
    VT_BSTAR = 64,
    VT_MEAN_MOTION_DOT = 66,
    VT_MEAN_MOTION_DDOT = 68,
    VT_COV_REF_FRAME = 70,
    VT_CX_X = 72,
    VT_CY_X = 74,
    VT_CY_Y = 76,
    VT_CZ_X = 78,
    VT_CZ_Y = 80,
    VT_CZ_Z = 82,
    VT_CX_DOT_X = 84,
    VT_CX_DOT_Y = 86,
    VT_CX_DOT_Z = 88,
    VT_CX_DOT_X_DOT = 90,
    VT_CY_DOT_X = 92,
    VT_CY_DOT_Y = 94,
    VT_CY_DOT_Z = 96,
    VT_CY_DOT_X_DOT = 98,
    VT_CY_DOT_Y_DOT = 100,
    VT_CZ_DOT_X = 102,
    VT_CZ_DOT_Y = 104,
    VT_CZ_DOT_Z = 106,
    VT_CZ_DOT_X_DOT = 108,
    VT_CZ_DOT_Y_DOT = 110,
    VT_CZ_DOT_Z_DOT = 112,
    VT_USER_DEFINED_BIP_0044_TYPE = 114,
    VT_USER_DEFINED_OBJECT_DESIGNATOR = 116,
    VT_USER_DEFINED_EARTH_MODEL = 118,
    VT_USER_DEFINED_EPOCH_TIMESTAMP = 120,
    VT_USER_DEFINED_MICROSECONDS = 122
  };
  double CCSDS_OMM_VERS() const {
    return GetField<double>(VT_CCSDS_OMM_VERS, 0.0);
  }
  bool mutate_CCSDS_OMM_VERS(double _CCSDS_OMM_VERS) {
    return SetField<double>(VT_CCSDS_OMM_VERS, _CCSDS_OMM_VERS, 0.0);
  }
  const flatbuffers::String *CREATION_DATE() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATION_DATE);
  }
  flatbuffers::String *mutable_CREATION_DATE() {
    return GetPointer<flatbuffers::String *>(VT_CREATION_DATE);
  }
  const flatbuffers::String *ORIGINATOR() const {
    return GetPointer<const flatbuffers::String *>(VT_ORIGINATOR);
  }
  flatbuffers::String *mutable_ORIGINATOR() {
    return GetPointer<flatbuffers::String *>(VT_ORIGINATOR);
  }
  const flatbuffers::String *OBJECT_NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_NAME);
  }
  flatbuffers::String *mutable_OBJECT_NAME() {
    return GetPointer<flatbuffers::String *>(VT_OBJECT_NAME);
  }
  const flatbuffers::String *OBJECT_ID() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
  }
  flatbuffers::String *mutable_OBJECT_ID() {
    return GetPointer<flatbuffers::String *>(VT_OBJECT_ID);
  }
  const flatbuffers::String *CENTER_NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_CENTER_NAME);
  }
  flatbuffers::String *mutable_CENTER_NAME() {
    return GetPointer<flatbuffers::String *>(VT_CENTER_NAME);
  }
  referenceFrame REF_FRAME() const {
    return static_cast<referenceFrame>(GetField<int8_t>(VT_REF_FRAME, 9));
  }
  bool mutate_REF_FRAME(referenceFrame _REF_FRAME) {
    return SetField<int8_t>(VT_REF_FRAME, static_cast<int8_t>(_REF_FRAME), 9);
  }
  const flatbuffers::String *REF_FRAME_EPOCH() const {
    return GetPointer<const flatbuffers::String *>(VT_REF_FRAME_EPOCH);
  }
  flatbuffers::String *mutable_REF_FRAME_EPOCH() {
    return GetPointer<flatbuffers::String *>(VT_REF_FRAME_EPOCH);
  }
  timeSystem TIME_SYSTEM() const {
    return static_cast<timeSystem>(GetField<int8_t>(VT_TIME_SYSTEM, 11));
  }
  bool mutate_TIME_SYSTEM(timeSystem _TIME_SYSTEM) {
    return SetField<int8_t>(VT_TIME_SYSTEM, static_cast<int8_t>(_TIME_SYSTEM), 11);
  }
  meanElementTheory MEAN_ELEMENT_THEORY() const {
    return static_cast<meanElementTheory>(GetField<int8_t>(VT_MEAN_ELEMENT_THEORY, 0));
  }
  bool mutate_MEAN_ELEMENT_THEORY(meanElementTheory _MEAN_ELEMENT_THEORY) {
    return SetField<int8_t>(VT_MEAN_ELEMENT_THEORY, static_cast<int8_t>(_MEAN_ELEMENT_THEORY), 0);
  }
  const flatbuffers::String *COMMENT() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMENT);
  }
  flatbuffers::String *mutable_COMMENT() {
    return GetPointer<flatbuffers::String *>(VT_COMMENT);
  }
  const flatbuffers::String *EPOCH() const {
    return GetPointer<const flatbuffers::String *>(VT_EPOCH);
  }
  flatbuffers::String *mutable_EPOCH() {
    return GetPointer<flatbuffers::String *>(VT_EPOCH);
  }
  double SEMI_MAJOR_AXIS() const {
    return GetField<double>(VT_SEMI_MAJOR_AXIS, 0.0);
  }
  bool mutate_SEMI_MAJOR_AXIS(double _SEMI_MAJOR_AXIS) {
    return SetField<double>(VT_SEMI_MAJOR_AXIS, _SEMI_MAJOR_AXIS, 0.0);
  }
  double MEAN_MOTION() const {
    return GetField<double>(VT_MEAN_MOTION, 0.0);
  }
  bool mutate_MEAN_MOTION(double _MEAN_MOTION) {
    return SetField<double>(VT_MEAN_MOTION, _MEAN_MOTION, 0.0);
  }
  double ECCENTRICITY() const {
    return GetField<double>(VT_ECCENTRICITY, 0.0);
  }
  bool mutate_ECCENTRICITY(double _ECCENTRICITY) {
    return SetField<double>(VT_ECCENTRICITY, _ECCENTRICITY, 0.0);
  }
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  bool mutate_INCLINATION(double _INCLINATION) {
    return SetField<double>(VT_INCLINATION, _INCLINATION, 0.0);
  }
  double RA_OF_ASC_NODE() const {
    return GetField<double>(VT_RA_OF_ASC_NODE, 0.0);
  }
  bool mutate_RA_OF_ASC_NODE(double _RA_OF_ASC_NODE) {
    return SetField<double>(VT_RA_OF_ASC_NODE, _RA_OF_ASC_NODE, 0.0);
  }
  double ARG_OF_PERICENTER() const {
    return GetField<double>(VT_ARG_OF_PERICENTER, 0.0);
  }
  bool mutate_ARG_OF_PERICENTER(double _ARG_OF_PERICENTER) {
    return SetField<double>(VT_ARG_OF_PERICENTER, _ARG_OF_PERICENTER, 0.0);
  }
  double MEAN_ANOMALY() const {
    return GetField<double>(VT_MEAN_ANOMALY, 0.0);
  }
  bool mutate_MEAN_ANOMALY(double _MEAN_ANOMALY) {
    return SetField<double>(VT_MEAN_ANOMALY, _MEAN_ANOMALY, 0.0);
  }
  double GM() const {
    return GetField<double>(VT_GM, 0.0);
  }
  bool mutate_GM(double _GM) {
    return SetField<double>(VT_GM, _GM, 0.0);
  }
  double MASS() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  bool mutate_MASS(double _MASS) {
    return SetField<double>(VT_MASS, _MASS, 0.0);
  }
  double SOLAR_RAD_AREA() const {
    return GetField<double>(VT_SOLAR_RAD_AREA, 0.0);
  }
  bool mutate_SOLAR_RAD_AREA(double _SOLAR_RAD_AREA) {
    return SetField<double>(VT_SOLAR_RAD_AREA, _SOLAR_RAD_AREA, 0.0);
  }
  double SOLAR_RAD_COEFF() const {
    return GetField<double>(VT_SOLAR_RAD_COEFF, 0.0);
  }
  bool mutate_SOLAR_RAD_COEFF(double _SOLAR_RAD_COEFF) {
    return SetField<double>(VT_SOLAR_RAD_COEFF, _SOLAR_RAD_COEFF, 0.0);
  }
  double DRAG_AREA() const {
    return GetField<double>(VT_DRAG_AREA, 0.0);
  }
  bool mutate_DRAG_AREA(double _DRAG_AREA) {
    return SetField<double>(VT_DRAG_AREA, _DRAG_AREA, 0.0);
  }
  double DRAG_COEFF() const {
    return GetField<double>(VT_DRAG_COEFF, 0.0);
  }
  bool mutate_DRAG_COEFF(double _DRAG_COEFF) {
    return SetField<double>(VT_DRAG_COEFF, _DRAG_COEFF, 0.0);
  }
  ephemerisType EPHEMERIS_TYPE() const {
    return static_cast<ephemerisType>(GetField<int8_t>(VT_EPHEMERIS_TYPE, 1));
  }
  bool mutate_EPHEMERIS_TYPE(ephemerisType _EPHEMERIS_TYPE) {
    return SetField<int8_t>(VT_EPHEMERIS_TYPE, static_cast<int8_t>(_EPHEMERIS_TYPE), 1);
  }
  const flatbuffers::String *CLASSIFICATION_TYPE() const {
    return GetPointer<const flatbuffers::String *>(VT_CLASSIFICATION_TYPE);
  }
  flatbuffers::String *mutable_CLASSIFICATION_TYPE() {
    return GetPointer<flatbuffers::String *>(VT_CLASSIFICATION_TYPE);
  }
  uint32_t NORAD_CAT_ID() const {
    return GetField<uint32_t>(VT_NORAD_CAT_ID, 0);
  }
  bool mutate_NORAD_CAT_ID(uint32_t _NORAD_CAT_ID) {
    return SetField<uint32_t>(VT_NORAD_CAT_ID, _NORAD_CAT_ID, 0);
  }
  uint32_t ELEMENT_SET_NO() const {
    return GetField<uint32_t>(VT_ELEMENT_SET_NO, 0);
  }
  bool mutate_ELEMENT_SET_NO(uint32_t _ELEMENT_SET_NO) {
    return SetField<uint32_t>(VT_ELEMENT_SET_NO, _ELEMENT_SET_NO, 0);
  }
  double REV_AT_EPOCH() const {
    return GetField<double>(VT_REV_AT_EPOCH, 0.0);
  }
  bool mutate_REV_AT_EPOCH(double _REV_AT_EPOCH) {
    return SetField<double>(VT_REV_AT_EPOCH, _REV_AT_EPOCH, 0.0);
  }
  double BSTAR() const {
    return GetField<double>(VT_BSTAR, 0.0);
  }
  bool mutate_BSTAR(double _BSTAR) {
    return SetField<double>(VT_BSTAR, _BSTAR, 0.0);
  }
  double MEAN_MOTION_DOT() const {
    return GetField<double>(VT_MEAN_MOTION_DOT, 0.0);
  }
  bool mutate_MEAN_MOTION_DOT(double _MEAN_MOTION_DOT) {
    return SetField<double>(VT_MEAN_MOTION_DOT, _MEAN_MOTION_DOT, 0.0);
  }
  double MEAN_MOTION_DDOT() const {
    return GetField<double>(VT_MEAN_MOTION_DDOT, 0.0);
  }
  bool mutate_MEAN_MOTION_DDOT(double _MEAN_MOTION_DDOT) {
    return SetField<double>(VT_MEAN_MOTION_DDOT, _MEAN_MOTION_DDOT, 0.0);
  }
  manCovRefFrame COV_REF_FRAME() const {
    return static_cast<manCovRefFrame>(GetField<int8_t>(VT_COV_REF_FRAME, 0));
  }
  bool mutate_COV_REF_FRAME(manCovRefFrame _COV_REF_FRAME) {
    return SetField<int8_t>(VT_COV_REF_FRAME, static_cast<int8_t>(_COV_REF_FRAME), 0);
  }
  double CX_X() const {
    return GetField<double>(VT_CX_X, 0.0);
  }
  bool mutate_CX_X(double _CX_X) {
    return SetField<double>(VT_CX_X, _CX_X, 0.0);
  }
  double CY_X() const {
    return GetField<double>(VT_CY_X, 0.0);
  }
  bool mutate_CY_X(double _CY_X) {
    return SetField<double>(VT_CY_X, _CY_X, 0.0);
  }
  double CY_Y() const {
    return GetField<double>(VT_CY_Y, 0.0);
  }
  bool mutate_CY_Y(double _CY_Y) {
    return SetField<double>(VT_CY_Y, _CY_Y, 0.0);
  }
  double CZ_X() const {
    return GetField<double>(VT_CZ_X, 0.0);
  }
  bool mutate_CZ_X(double _CZ_X) {
    return SetField<double>(VT_CZ_X, _CZ_X, 0.0);
  }
  double CZ_Y() const {
    return GetField<double>(VT_CZ_Y, 0.0);
  }
  bool mutate_CZ_Y(double _CZ_Y) {
    return SetField<double>(VT_CZ_Y, _CZ_Y, 0.0);
  }
  double CZ_Z() const {
    return GetField<double>(VT_CZ_Z, 0.0);
  }
  bool mutate_CZ_Z(double _CZ_Z) {
    return SetField<double>(VT_CZ_Z, _CZ_Z, 0.0);
  }
  double CX_DOT_X() const {
    return GetField<double>(VT_CX_DOT_X, 0.0);
  }
  bool mutate_CX_DOT_X(double _CX_DOT_X) {
    return SetField<double>(VT_CX_DOT_X, _CX_DOT_X, 0.0);
  }
  double CX_DOT_Y() const {
    return GetField<double>(VT_CX_DOT_Y, 0.0);
  }
  bool mutate_CX_DOT_Y(double _CX_DOT_Y) {
    return SetField<double>(VT_CX_DOT_Y, _CX_DOT_Y, 0.0);
  }
  double CX_DOT_Z() const {
    return GetField<double>(VT_CX_DOT_Z, 0.0);
  }
  bool mutate_CX_DOT_Z(double _CX_DOT_Z) {
    return SetField<double>(VT_CX_DOT_Z, _CX_DOT_Z, 0.0);
  }
  double CX_DOT_X_DOT() const {
    return GetField<double>(VT_CX_DOT_X_DOT, 0.0);
  }
  bool mutate_CX_DOT_X_DOT(double _CX_DOT_X_DOT) {
    return SetField<double>(VT_CX_DOT_X_DOT, _CX_DOT_X_DOT, 0.0);
  }
  double CY_DOT_X() const {
    return GetField<double>(VT_CY_DOT_X, 0.0);
  }
  bool mutate_CY_DOT_X(double _CY_DOT_X) {
    return SetField<double>(VT_CY_DOT_X, _CY_DOT_X, 0.0);
  }
  double CY_DOT_Y() const {
    return GetField<double>(VT_CY_DOT_Y, 0.0);
  }
  bool mutate_CY_DOT_Y(double _CY_DOT_Y) {
    return SetField<double>(VT_CY_DOT_Y, _CY_DOT_Y, 0.0);
  }
  double CY_DOT_Z() const {
    return GetField<double>(VT_CY_DOT_Z, 0.0);
  }
  bool mutate_CY_DOT_Z(double _CY_DOT_Z) {
    return SetField<double>(VT_CY_DOT_Z, _CY_DOT_Z, 0.0);
  }
  double CY_DOT_X_DOT() const {
    return GetField<double>(VT_CY_DOT_X_DOT, 0.0);
  }
  bool mutate_CY_DOT_X_DOT(double _CY_DOT_X_DOT) {
    return SetField<double>(VT_CY_DOT_X_DOT, _CY_DOT_X_DOT, 0.0);
  }
  double CY_DOT_Y_DOT() const {
    return GetField<double>(VT_CY_DOT_Y_DOT, 0.0);
  }
  bool mutate_CY_DOT_Y_DOT(double _CY_DOT_Y_DOT) {
    return SetField<double>(VT_CY_DOT_Y_DOT, _CY_DOT_Y_DOT, 0.0);
  }
  double CZ_DOT_X() const {
    return GetField<double>(VT_CZ_DOT_X, 0.0);
  }
  bool mutate_CZ_DOT_X(double _CZ_DOT_X) {
    return SetField<double>(VT_CZ_DOT_X, _CZ_DOT_X, 0.0);
  }
  double CZ_DOT_Y() const {
    return GetField<double>(VT_CZ_DOT_Y, 0.0);
  }
  bool mutate_CZ_DOT_Y(double _CZ_DOT_Y) {
    return SetField<double>(VT_CZ_DOT_Y, _CZ_DOT_Y, 0.0);
  }
  double CZ_DOT_Z() const {
    return GetField<double>(VT_CZ_DOT_Z, 0.0);
  }
  bool mutate_CZ_DOT_Z(double _CZ_DOT_Z) {
    return SetField<double>(VT_CZ_DOT_Z, _CZ_DOT_Z, 0.0);
  }
  double CZ_DOT_X_DOT() const {
    return GetField<double>(VT_CZ_DOT_X_DOT, 0.0);
  }
  bool mutate_CZ_DOT_X_DOT(double _CZ_DOT_X_DOT) {
    return SetField<double>(VT_CZ_DOT_X_DOT, _CZ_DOT_X_DOT, 0.0);
  }
  double CZ_DOT_Y_DOT() const {
    return GetField<double>(VT_CZ_DOT_Y_DOT, 0.0);
  }
  bool mutate_CZ_DOT_Y_DOT(double _CZ_DOT_Y_DOT) {
    return SetField<double>(VT_CZ_DOT_Y_DOT, _CZ_DOT_Y_DOT, 0.0);
  }
  double CZ_DOT_Z_DOT() const {
    return GetField<double>(VT_CZ_DOT_Z_DOT, 0.0);
  }
  bool mutate_CZ_DOT_Z_DOT(double _CZ_DOT_Z_DOT) {
    return SetField<double>(VT_CZ_DOT_Z_DOT, _CZ_DOT_Z_DOT, 0.0);
  }
  uint32_t USER_DEFINED_BIP_0044_TYPE() const {
    return GetField<uint32_t>(VT_USER_DEFINED_BIP_0044_TYPE, 0);
  }
  bool mutate_USER_DEFINED_BIP_0044_TYPE(uint32_t _USER_DEFINED_BIP_0044_TYPE) {
    return SetField<uint32_t>(VT_USER_DEFINED_BIP_0044_TYPE, _USER_DEFINED_BIP_0044_TYPE, 0);
  }
  const flatbuffers::String *USER_DEFINED_OBJECT_DESIGNATOR() const {
    return GetPointer<const flatbuffers::String *>(VT_USER_DEFINED_OBJECT_DESIGNATOR);
  }
  flatbuffers::String *mutable_USER_DEFINED_OBJECT_DESIGNATOR() {
    return GetPointer<flatbuffers::String *>(VT_USER_DEFINED_OBJECT_DESIGNATOR);
  }
  const flatbuffers::String *USER_DEFINED_EARTH_MODEL() const {
    return GetPointer<const flatbuffers::String *>(VT_USER_DEFINED_EARTH_MODEL);
  }
  flatbuffers::String *mutable_USER_DEFINED_EARTH_MODEL() {
    return GetPointer<flatbuffers::String *>(VT_USER_DEFINED_EARTH_MODEL);
  }
  double USER_DEFINED_EPOCH_TIMESTAMP() const {
    return GetField<double>(VT_USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
  }
  bool mutate_USER_DEFINED_EPOCH_TIMESTAMP(double _USER_DEFINED_EPOCH_TIMESTAMP) {
    return SetField<double>(VT_USER_DEFINED_EPOCH_TIMESTAMP, _USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
  }
  double USER_DEFINED_MICROSECONDS() const {
    return GetField<double>(VT_USER_DEFINED_MICROSECONDS, 0.0);
  }
  bool mutate_USER_DEFINED_MICROSECONDS(double _USER_DEFINED_MICROSECONDS) {
    return SetField<double>(VT_USER_DEFINED_MICROSECONDS, _USER_DEFINED_MICROSECONDS, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_CCSDS_OMM_VERS) &&
           VerifyOffset(verifier, VT_CREATION_DATE) &&
           verifier.VerifyString(CREATION_DATE()) &&
           VerifyOffset(verifier, VT_ORIGINATOR) &&
           verifier.VerifyString(ORIGINATOR()) &&
           VerifyOffset(verifier, VT_OBJECT_NAME) &&
           verifier.VerifyString(OBJECT_NAME()) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(OBJECT_ID()) &&
           VerifyOffset(verifier, VT_CENTER_NAME) &&
           verifier.VerifyString(CENTER_NAME()) &&
           VerifyField<int8_t>(verifier, VT_REF_FRAME) &&
           VerifyOffset(verifier, VT_REF_FRAME_EPOCH) &&
           verifier.VerifyString(REF_FRAME_EPOCH()) &&
           VerifyField<int8_t>(verifier, VT_TIME_SYSTEM) &&
           VerifyField<int8_t>(verifier, VT_MEAN_ELEMENT_THEORY) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyString(COMMENT()) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(EPOCH()) &&
           VerifyField<double>(verifier, VT_SEMI_MAJOR_AXIS) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION) &&
           VerifyField<double>(verifier, VT_ECCENTRICITY) &&
           VerifyField<double>(verifier, VT_INCLINATION) &&
           VerifyField<double>(verifier, VT_RA_OF_ASC_NODE) &&
           VerifyField<double>(verifier, VT_ARG_OF_PERICENTER) &&
           VerifyField<double>(verifier, VT_MEAN_ANOMALY) &&
           VerifyField<double>(verifier, VT_GM) &&
           VerifyField<double>(verifier, VT_MASS) &&
           VerifyField<double>(verifier, VT_SOLAR_RAD_AREA) &&
           VerifyField<double>(verifier, VT_SOLAR_RAD_COEFF) &&
           VerifyField<double>(verifier, VT_DRAG_AREA) &&
           VerifyField<double>(verifier, VT_DRAG_COEFF) &&
           VerifyField<int8_t>(verifier, VT_EPHEMERIS_TYPE) &&
           VerifyOffset(verifier, VT_CLASSIFICATION_TYPE) &&
           verifier.VerifyString(CLASSIFICATION_TYPE()) &&
           VerifyField<uint32_t>(verifier, VT_NORAD_CAT_ID) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_SET_NO) &&
           VerifyField<double>(verifier, VT_REV_AT_EPOCH) &&
           VerifyField<double>(verifier, VT_BSTAR) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION_DOT) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION_DDOT) &&
           VerifyField<int8_t>(verifier, VT_COV_REF_FRAME) &&
           VerifyField<double>(verifier, VT_CX_X) &&
           VerifyField<double>(verifier, VT_CY_X) &&
           VerifyField<double>(verifier, VT_CY_Y) &&
           VerifyField<double>(verifier, VT_CZ_X) &&
           VerifyField<double>(verifier, VT_CZ_Y) &&
           VerifyField<double>(verifier, VT_CZ_Z) &&
           VerifyField<double>(verifier, VT_CX_DOT_X) &&
           VerifyField<double>(verifier, VT_CX_DOT_Y) &&
           VerifyField<double>(verifier, VT_CX_DOT_Z) &&
           VerifyField<double>(verifier, VT_CX_DOT_X_DOT) &&
           VerifyField<double>(verifier, VT_CY_DOT_X) &&
           VerifyField<double>(verifier, VT_CY_DOT_Y) &&
           VerifyField<double>(verifier, VT_CY_DOT_Z) &&
           VerifyField<double>(verifier, VT_CY_DOT_X_DOT) &&
           VerifyField<double>(verifier, VT_CY_DOT_Y_DOT) &&
           VerifyField<double>(verifier, VT_CZ_DOT_X) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Y) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Z) &&
           VerifyField<double>(verifier, VT_CZ_DOT_X_DOT) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Y_DOT) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Z_DOT) &&
           VerifyField<uint32_t>(verifier, VT_USER_DEFINED_BIP_0044_TYPE) &&
           VerifyOffset(verifier, VT_USER_DEFINED_OBJECT_DESIGNATOR) &&
           verifier.VerifyString(USER_DEFINED_OBJECT_DESIGNATOR()) &&
           VerifyOffset(verifier, VT_USER_DEFINED_EARTH_MODEL) &&
           verifier.VerifyString(USER_DEFINED_EARTH_MODEL()) &&
           VerifyField<double>(verifier, VT_USER_DEFINED_EPOCH_TIMESTAMP) &&
           VerifyField<double>(verifier, VT_USER_DEFINED_MICROSECONDS) &&
           verifier.EndTable();
  }
};

struct OMMBuilder {
  typedef OMM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CCSDS_OMM_VERS(double CCSDS_OMM_VERS) {
    fbb_.AddElement<double>(OMM::VT_CCSDS_OMM_VERS, CCSDS_OMM_VERS, 0.0);
  }
  void add_CREATION_DATE(flatbuffers::Offset<flatbuffers::String> CREATION_DATE) {
    fbb_.AddOffset(OMM::VT_CREATION_DATE, CREATION_DATE);
  }
  void add_ORIGINATOR(flatbuffers::Offset<flatbuffers::String> ORIGINATOR) {
    fbb_.AddOffset(OMM::VT_ORIGINATOR, ORIGINATOR);
  }
  void add_OBJECT_NAME(flatbuffers::Offset<flatbuffers::String> OBJECT_NAME) {
    fbb_.AddOffset(OMM::VT_OBJECT_NAME, OBJECT_NAME);
  }
  void add_OBJECT_ID(flatbuffers::Offset<flatbuffers::String> OBJECT_ID) {
    fbb_.AddOffset(OMM::VT_OBJECT_ID, OBJECT_ID);
  }
  void add_CENTER_NAME(flatbuffers::Offset<flatbuffers::String> CENTER_NAME) {
    fbb_.AddOffset(OMM::VT_CENTER_NAME, CENTER_NAME);
  }
  void add_REF_FRAME(referenceFrame REF_FRAME) {
    fbb_.AddElement<int8_t>(OMM::VT_REF_FRAME, static_cast<int8_t>(REF_FRAME), 9);
  }
  void add_REF_FRAME_EPOCH(flatbuffers::Offset<flatbuffers::String> REF_FRAME_EPOCH) {
    fbb_.AddOffset(OMM::VT_REF_FRAME_EPOCH, REF_FRAME_EPOCH);
  }
  void add_TIME_SYSTEM(timeSystem TIME_SYSTEM) {
    fbb_.AddElement<int8_t>(OMM::VT_TIME_SYSTEM, static_cast<int8_t>(TIME_SYSTEM), 11);
  }
  void add_MEAN_ELEMENT_THEORY(meanElementTheory MEAN_ELEMENT_THEORY) {
    fbb_.AddElement<int8_t>(OMM::VT_MEAN_ELEMENT_THEORY, static_cast<int8_t>(MEAN_ELEMENT_THEORY), 0);
  }
  void add_COMMENT(flatbuffers::Offset<flatbuffers::String> COMMENT) {
    fbb_.AddOffset(OMM::VT_COMMENT, COMMENT);
  }
  void add_EPOCH(flatbuffers::Offset<flatbuffers::String> EPOCH) {
    fbb_.AddOffset(OMM::VT_EPOCH, EPOCH);
  }
  void add_SEMI_MAJOR_AXIS(double SEMI_MAJOR_AXIS) {
    fbb_.AddElement<double>(OMM::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  void add_MEAN_MOTION(double MEAN_MOTION) {
    fbb_.AddElement<double>(OMM::VT_MEAN_MOTION, MEAN_MOTION, 0.0);
  }
  void add_ECCENTRICITY(double ECCENTRICITY) {
    fbb_.AddElement<double>(OMM::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(OMM::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_RA_OF_ASC_NODE(double RA_OF_ASC_NODE) {
    fbb_.AddElement<double>(OMM::VT_RA_OF_ASC_NODE, RA_OF_ASC_NODE, 0.0);
  }
  void add_ARG_OF_PERICENTER(double ARG_OF_PERICENTER) {
    fbb_.AddElement<double>(OMM::VT_ARG_OF_PERICENTER, ARG_OF_PERICENTER, 0.0);
  }
  void add_MEAN_ANOMALY(double MEAN_ANOMALY) {
    fbb_.AddElement<double>(OMM::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  void add_GM(double GM) {
    fbb_.AddElement<double>(OMM::VT_GM, GM, 0.0);
  }
  void add_MASS(double MASS) {
    fbb_.AddElement<double>(OMM::VT_MASS, MASS, 0.0);
  }
  void add_SOLAR_RAD_AREA(double SOLAR_RAD_AREA) {
    fbb_.AddElement<double>(OMM::VT_SOLAR_RAD_AREA, SOLAR_RAD_AREA, 0.0);
  }
  void add_SOLAR_RAD_COEFF(double SOLAR_RAD_COEFF) {
    fbb_.AddElement<double>(OMM::VT_SOLAR_RAD_COEFF, SOLAR_RAD_COEFF, 0.0);
  }
  void add_DRAG_AREA(double DRAG_AREA) {
    fbb_.AddElement<double>(OMM::VT_DRAG_AREA, DRAG_AREA, 0.0);
  }
  void add_DRAG_COEFF(double DRAG_COEFF) {
    fbb_.AddElement<double>(OMM::VT_DRAG_COEFF, DRAG_COEFF, 0.0);
  }
  void add_EPHEMERIS_TYPE(ephemerisType EPHEMERIS_TYPE) {
    fbb_.AddElement<int8_t>(OMM::VT_EPHEMERIS_TYPE, static_cast<int8_t>(EPHEMERIS_TYPE), 1);
  }
  void add_CLASSIFICATION_TYPE(flatbuffers::Offset<flatbuffers::String> CLASSIFICATION_TYPE) {
    fbb_.AddOffset(OMM::VT_CLASSIFICATION_TYPE, CLASSIFICATION_TYPE);
  }
  void add_NORAD_CAT_ID(uint32_t NORAD_CAT_ID) {
    fbb_.AddElement<uint32_t>(OMM::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  void add_ELEMENT_SET_NO(uint32_t ELEMENT_SET_NO) {
    fbb_.AddElement<uint32_t>(OMM::VT_ELEMENT_SET_NO, ELEMENT_SET_NO, 0);
  }
  void add_REV_AT_EPOCH(double REV_AT_EPOCH) {
    fbb_.AddElement<double>(OMM::VT_REV_AT_EPOCH, REV_AT_EPOCH, 0.0);
  }
  void add_BSTAR(double BSTAR) {
    fbb_.AddElement<double>(OMM::VT_BSTAR, BSTAR, 0.0);
  }
  void add_MEAN_MOTION_DOT(double MEAN_MOTION_DOT) {
    fbb_.AddElement<double>(OMM::VT_MEAN_MOTION_DOT, MEAN_MOTION_DOT, 0.0);
  }
  void add_MEAN_MOTION_DDOT(double MEAN_MOTION_DDOT) {
    fbb_.AddElement<double>(OMM::VT_MEAN_MOTION_DDOT, MEAN_MOTION_DDOT, 0.0);
  }
  void add_COV_REF_FRAME(manCovRefFrame COV_REF_FRAME) {
    fbb_.AddElement<int8_t>(OMM::VT_COV_REF_FRAME, static_cast<int8_t>(COV_REF_FRAME), 0);
  }
  void add_CX_X(double CX_X) {
    fbb_.AddElement<double>(OMM::VT_CX_X, CX_X, 0.0);
  }
  void add_CY_X(double CY_X) {
    fbb_.AddElement<double>(OMM::VT_CY_X, CY_X, 0.0);
  }
  void add_CY_Y(double CY_Y) {
    fbb_.AddElement<double>(OMM::VT_CY_Y, CY_Y, 0.0);
  }
  void add_CZ_X(double CZ_X) {
    fbb_.AddElement<double>(OMM::VT_CZ_X, CZ_X, 0.0);
  }
  void add_CZ_Y(double CZ_Y) {
    fbb_.AddElement<double>(OMM::VT_CZ_Y, CZ_Y, 0.0);
  }
  void add_CZ_Z(double CZ_Z) {
    fbb_.AddElement<double>(OMM::VT_CZ_Z, CZ_Z, 0.0);
  }
  void add_CX_DOT_X(double CX_DOT_X) {
    fbb_.AddElement<double>(OMM::VT_CX_DOT_X, CX_DOT_X, 0.0);
  }
  void add_CX_DOT_Y(double CX_DOT_Y) {
    fbb_.AddElement<double>(OMM::VT_CX_DOT_Y, CX_DOT_Y, 0.0);
  }
  void add_CX_DOT_Z(double CX_DOT_Z) {
    fbb_.AddElement<double>(OMM::VT_CX_DOT_Z, CX_DOT_Z, 0.0);
  }
  void add_CX_DOT_X_DOT(double CX_DOT_X_DOT) {
    fbb_.AddElement<double>(OMM::VT_CX_DOT_X_DOT, CX_DOT_X_DOT, 0.0);
  }
  void add_CY_DOT_X(double CY_DOT_X) {
    fbb_.AddElement<double>(OMM::VT_CY_DOT_X, CY_DOT_X, 0.0);
  }
  void add_CY_DOT_Y(double CY_DOT_Y) {
    fbb_.AddElement<double>(OMM::VT_CY_DOT_Y, CY_DOT_Y, 0.0);
  }
  void add_CY_DOT_Z(double CY_DOT_Z) {
    fbb_.AddElement<double>(OMM::VT_CY_DOT_Z, CY_DOT_Z, 0.0);
  }
  void add_CY_DOT_X_DOT(double CY_DOT_X_DOT) {
    fbb_.AddElement<double>(OMM::VT_CY_DOT_X_DOT, CY_DOT_X_DOT, 0.0);
  }
  void add_CY_DOT_Y_DOT(double CY_DOT_Y_DOT) {
    fbb_.AddElement<double>(OMM::VT_CY_DOT_Y_DOT, CY_DOT_Y_DOT, 0.0);
  }
  void add_CZ_DOT_X(double CZ_DOT_X) {
    fbb_.AddElement<double>(OMM::VT_CZ_DOT_X, CZ_DOT_X, 0.0);
  }
  void add_CZ_DOT_Y(double CZ_DOT_Y) {
    fbb_.AddElement<double>(OMM::VT_CZ_DOT_Y, CZ_DOT_Y, 0.0);
  }
  void add_CZ_DOT_Z(double CZ_DOT_Z) {
    fbb_.AddElement<double>(OMM::VT_CZ_DOT_Z, CZ_DOT_Z, 0.0);
  }
  void add_CZ_DOT_X_DOT(double CZ_DOT_X_DOT) {
    fbb_.AddElement<double>(OMM::VT_CZ_DOT_X_DOT, CZ_DOT_X_DOT, 0.0);
  }
  void add_CZ_DOT_Y_DOT(double CZ_DOT_Y_DOT) {
    fbb_.AddElement<double>(OMM::VT_CZ_DOT_Y_DOT, CZ_DOT_Y_DOT, 0.0);
  }
  void add_CZ_DOT_Z_DOT(double CZ_DOT_Z_DOT) {
    fbb_.AddElement<double>(OMM::VT_CZ_DOT_Z_DOT, CZ_DOT_Z_DOT, 0.0);
  }
  void add_USER_DEFINED_BIP_0044_TYPE(uint32_t USER_DEFINED_BIP_0044_TYPE) {
    fbb_.AddElement<uint32_t>(OMM::VT_USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  void add_USER_DEFINED_OBJECT_DESIGNATOR(flatbuffers::Offset<flatbuffers::String> USER_DEFINED_OBJECT_DESIGNATOR) {
    fbb_.AddOffset(OMM::VT_USER_DEFINED_OBJECT_DESIGNATOR, USER_DEFINED_OBJECT_DESIGNATOR);
  }
  void add_USER_DEFINED_EARTH_MODEL(flatbuffers::Offset<flatbuffers::String> USER_DEFINED_EARTH_MODEL) {
    fbb_.AddOffset(OMM::VT_USER_DEFINED_EARTH_MODEL, USER_DEFINED_EARTH_MODEL);
  }
  void add_USER_DEFINED_EPOCH_TIMESTAMP(double USER_DEFINED_EPOCH_TIMESTAMP) {
    fbb_.AddElement<double>(OMM::VT_USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
  }
  void add_USER_DEFINED_MICROSECONDS(double USER_DEFINED_MICROSECONDS) {
    fbb_.AddElement<double>(OMM::VT_USER_DEFINED_MICROSECONDS, USER_DEFINED_MICROSECONDS, 0.0);
  }
  explicit OMMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OMM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OMM>(end);
    return o;
  }
};

inline flatbuffers::Offset<OMM> CreateOMM(
    flatbuffers::FlatBufferBuilder &_fbb,
    double CCSDS_OMM_VERS = 0.0,
    flatbuffers::Offset<flatbuffers::String> CREATION_DATE = 0,
    flatbuffers::Offset<flatbuffers::String> ORIGINATOR = 0,
    flatbuffers::Offset<flatbuffers::String> OBJECT_NAME = 0,
    flatbuffers::Offset<flatbuffers::String> OBJECT_ID = 0,
    flatbuffers::Offset<flatbuffers::String> CENTER_NAME = 0,
    referenceFrame REF_FRAME = referenceFrame_TEME,
    flatbuffers::Offset<flatbuffers::String> REF_FRAME_EPOCH = 0,
    timeSystem TIME_SYSTEM = timeSystem_UTC,
    meanElementTheory MEAN_ELEMENT_THEORY = meanElementTheory_SGP4,
    flatbuffers::Offset<flatbuffers::String> COMMENT = 0,
    flatbuffers::Offset<flatbuffers::String> EPOCH = 0,
    double SEMI_MAJOR_AXIS = 0.0,
    double MEAN_MOTION = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RA_OF_ASC_NODE = 0.0,
    double ARG_OF_PERICENTER = 0.0,
    double MEAN_ANOMALY = 0.0,
    double GM = 0.0,
    double MASS = 0.0,
    double SOLAR_RAD_AREA = 0.0,
    double SOLAR_RAD_COEFF = 0.0,
    double DRAG_AREA = 0.0,
    double DRAG_COEFF = 0.0,
    ephemerisType EPHEMERIS_TYPE = ephemerisType_SGP4,
    flatbuffers::Offset<flatbuffers::String> CLASSIFICATION_TYPE = 0,
    uint32_t NORAD_CAT_ID = 0,
    uint32_t ELEMENT_SET_NO = 0,
    double REV_AT_EPOCH = 0.0,
    double BSTAR = 0.0,
    double MEAN_MOTION_DOT = 0.0,
    double MEAN_MOTION_DDOT = 0.0,
    manCovRefFrame COV_REF_FRAME = manCovRefFrame_RSW,
    double CX_X = 0.0,
    double CY_X = 0.0,
    double CY_Y = 0.0,
    double CZ_X = 0.0,
    double CZ_Y = 0.0,
    double CZ_Z = 0.0,
    double CX_DOT_X = 0.0,
    double CX_DOT_Y = 0.0,
    double CX_DOT_Z = 0.0,
    double CX_DOT_X_DOT = 0.0,
    double CY_DOT_X = 0.0,
    double CY_DOT_Y = 0.0,
    double CY_DOT_Z = 0.0,
    double CY_DOT_X_DOT = 0.0,
    double CY_DOT_Y_DOT = 0.0,
    double CZ_DOT_X = 0.0,
    double CZ_DOT_Y = 0.0,
    double CZ_DOT_Z = 0.0,
    double CZ_DOT_X_DOT = 0.0,
    double CZ_DOT_Y_DOT = 0.0,
    double CZ_DOT_Z_DOT = 0.0,
    uint32_t USER_DEFINED_BIP_0044_TYPE = 0,
    flatbuffers::Offset<flatbuffers::String> USER_DEFINED_OBJECT_DESIGNATOR = 0,
    flatbuffers::Offset<flatbuffers::String> USER_DEFINED_EARTH_MODEL = 0,
    double USER_DEFINED_EPOCH_TIMESTAMP = 0.0,
    double USER_DEFINED_MICROSECONDS = 0.0) {
  OMMBuilder builder_(_fbb);
  builder_.add_USER_DEFINED_MICROSECONDS(USER_DEFINED_MICROSECONDS);
  builder_.add_USER_DEFINED_EPOCH_TIMESTAMP(USER_DEFINED_EPOCH_TIMESTAMP);
  builder_.add_CZ_DOT_Z_DOT(CZ_DOT_Z_DOT);
  builder_.add_CZ_DOT_Y_DOT(CZ_DOT_Y_DOT);
  builder_.add_CZ_DOT_X_DOT(CZ_DOT_X_DOT);
  builder_.add_CZ_DOT_Z(CZ_DOT_Z);
  builder_.add_CZ_DOT_Y(CZ_DOT_Y);
  builder_.add_CZ_DOT_X(CZ_DOT_X);
  builder_.add_CY_DOT_Y_DOT(CY_DOT_Y_DOT);
  builder_.add_CY_DOT_X_DOT(CY_DOT_X_DOT);
  builder_.add_CY_DOT_Z(CY_DOT_Z);
  builder_.add_CY_DOT_Y(CY_DOT_Y);
  builder_.add_CY_DOT_X(CY_DOT_X);
  builder_.add_CX_DOT_X_DOT(CX_DOT_X_DOT);
  builder_.add_CX_DOT_Z(CX_DOT_Z);
  builder_.add_CX_DOT_Y(CX_DOT_Y);
  builder_.add_CX_DOT_X(CX_DOT_X);
  builder_.add_CZ_Z(CZ_Z);
  builder_.add_CZ_Y(CZ_Y);
  builder_.add_CZ_X(CZ_X);
  builder_.add_CY_Y(CY_Y);
  builder_.add_CY_X(CY_X);
  builder_.add_CX_X(CX_X);
  builder_.add_MEAN_MOTION_DDOT(MEAN_MOTION_DDOT);
  builder_.add_MEAN_MOTION_DOT(MEAN_MOTION_DOT);
  builder_.add_BSTAR(BSTAR);
  builder_.add_REV_AT_EPOCH(REV_AT_EPOCH);
  builder_.add_DRAG_COEFF(DRAG_COEFF);
  builder_.add_DRAG_AREA(DRAG_AREA);
  builder_.add_SOLAR_RAD_COEFF(SOLAR_RAD_COEFF);
  builder_.add_SOLAR_RAD_AREA(SOLAR_RAD_AREA);
  builder_.add_MASS(MASS);
  builder_.add_GM(GM);
  builder_.add_MEAN_ANOMALY(MEAN_ANOMALY);
  builder_.add_ARG_OF_PERICENTER(ARG_OF_PERICENTER);
  builder_.add_RA_OF_ASC_NODE(RA_OF_ASC_NODE);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_ECCENTRICITY(ECCENTRICITY);
  builder_.add_MEAN_MOTION(MEAN_MOTION);
  builder_.add_SEMI_MAJOR_AXIS(SEMI_MAJOR_AXIS);
  builder_.add_CCSDS_OMM_VERS(CCSDS_OMM_VERS);
  builder_.add_USER_DEFINED_EARTH_MODEL(USER_DEFINED_EARTH_MODEL);
  builder_.add_USER_DEFINED_OBJECT_DESIGNATOR(USER_DEFINED_OBJECT_DESIGNATOR);
  builder_.add_USER_DEFINED_BIP_0044_TYPE(USER_DEFINED_BIP_0044_TYPE);
  builder_.add_ELEMENT_SET_NO(ELEMENT_SET_NO);
  builder_.add_NORAD_CAT_ID(NORAD_CAT_ID);
  builder_.add_CLASSIFICATION_TYPE(CLASSIFICATION_TYPE);
  builder_.add_EPOCH(EPOCH);
  builder_.add_COMMENT(COMMENT);
  builder_.add_REF_FRAME_EPOCH(REF_FRAME_EPOCH);
  builder_.add_CENTER_NAME(CENTER_NAME);
  builder_.add_OBJECT_ID(OBJECT_ID);
  builder_.add_OBJECT_NAME(OBJECT_NAME);
  builder_.add_ORIGINATOR(ORIGINATOR);
  builder_.add_CREATION_DATE(CREATION_DATE);
  builder_.add_COV_REF_FRAME(COV_REF_FRAME);
  builder_.add_EPHEMERIS_TYPE(EPHEMERIS_TYPE);
  builder_.add_MEAN_ELEMENT_THEORY(MEAN_ELEMENT_THEORY);
  builder_.add_TIME_SYSTEM(TIME_SYSTEM);
  builder_.add_REF_FRAME(REF_FRAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<OMM> CreateOMMDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double CCSDS_OMM_VERS = 0.0,
    const char *CREATION_DATE = nullptr,
    const char *ORIGINATOR = nullptr,
    const char *OBJECT_NAME = nullptr,
    const char *OBJECT_ID = nullptr,
    const char *CENTER_NAME = nullptr,
    referenceFrame REF_FRAME = referenceFrame_TEME,
    const char *REF_FRAME_EPOCH = nullptr,
    timeSystem TIME_SYSTEM = timeSystem_UTC,
    meanElementTheory MEAN_ELEMENT_THEORY = meanElementTheory_SGP4,
    const char *COMMENT = nullptr,
    const char *EPOCH = nullptr,
    double SEMI_MAJOR_AXIS = 0.0,
    double MEAN_MOTION = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RA_OF_ASC_NODE = 0.0,
    double ARG_OF_PERICENTER = 0.0,
    double MEAN_ANOMALY = 0.0,
    double GM = 0.0,
    double MASS = 0.0,
    double SOLAR_RAD_AREA = 0.0,
    double SOLAR_RAD_COEFF = 0.0,
    double DRAG_AREA = 0.0,
    double DRAG_COEFF = 0.0,
    ephemerisType EPHEMERIS_TYPE = ephemerisType_SGP4,
    const char *CLASSIFICATION_TYPE = nullptr,
    uint32_t NORAD_CAT_ID = 0,
    uint32_t ELEMENT_SET_NO = 0,
    double REV_AT_EPOCH = 0.0,
    double BSTAR = 0.0,
    double MEAN_MOTION_DOT = 0.0,
    double MEAN_MOTION_DDOT = 0.0,
    manCovRefFrame COV_REF_FRAME = manCovRefFrame_RSW,
    double CX_X = 0.0,
    double CY_X = 0.0,
    double CY_Y = 0.0,
    double CZ_X = 0.0,
    double CZ_Y = 0.0,
    double CZ_Z = 0.0,
    double CX_DOT_X = 0.0,
    double CX_DOT_Y = 0.0,
    double CX_DOT_Z = 0.0,
    double CX_DOT_X_DOT = 0.0,
    double CY_DOT_X = 0.0,
    double CY_DOT_Y = 0.0,
    double CY_DOT_Z = 0.0,
    double CY_DOT_X_DOT = 0.0,
    double CY_DOT_Y_DOT = 0.0,
    double CZ_DOT_X = 0.0,
    double CZ_DOT_Y = 0.0,
    double CZ_DOT_Z = 0.0,
    double CZ_DOT_X_DOT = 0.0,
    double CZ_DOT_Y_DOT = 0.0,
    double CZ_DOT_Z_DOT = 0.0,
    uint32_t USER_DEFINED_BIP_0044_TYPE = 0,
    const char *USER_DEFINED_OBJECT_DESIGNATOR = nullptr,
    const char *USER_DEFINED_EARTH_MODEL = nullptr,
    double USER_DEFINED_EPOCH_TIMESTAMP = 0.0,
    double USER_DEFINED_MICROSECONDS = 0.0) {
  auto CREATION_DATE__ = CREATION_DATE ? _fbb.CreateString(CREATION_DATE) : 0;
  auto ORIGINATOR__ = ORIGINATOR ? _fbb.CreateString(ORIGINATOR) : 0;
  auto OBJECT_NAME__ = OBJECT_NAME ? _fbb.CreateString(OBJECT_NAME) : 0;
  auto OBJECT_ID__ = OBJECT_ID ? _fbb.CreateString(OBJECT_ID) : 0;
  auto CENTER_NAME__ = CENTER_NAME ? _fbb.CreateString(CENTER_NAME) : 0;
  auto REF_FRAME_EPOCH__ = REF_FRAME_EPOCH ? _fbb.CreateString(REF_FRAME_EPOCH) : 0;
  auto COMMENT__ = COMMENT ? _fbb.CreateString(COMMENT) : 0;
  auto EPOCH__ = EPOCH ? _fbb.CreateString(EPOCH) : 0;
  auto CLASSIFICATION_TYPE__ = CLASSIFICATION_TYPE ? _fbb.CreateString(CLASSIFICATION_TYPE) : 0;
  auto USER_DEFINED_OBJECT_DESIGNATOR__ = USER_DEFINED_OBJECT_DESIGNATOR ? _fbb.CreateString(USER_DEFINED_OBJECT_DESIGNATOR) : 0;
  auto USER_DEFINED_EARTH_MODEL__ = USER_DEFINED_EARTH_MODEL ? _fbb.CreateString(USER_DEFINED_EARTH_MODEL) : 0;
  return CreateOMM(
      _fbb,
      CCSDS_OMM_VERS,
      CREATION_DATE__,
      ORIGINATOR__,
      OBJECT_NAME__,
      OBJECT_ID__,
      CENTER_NAME__,
      REF_FRAME,
      REF_FRAME_EPOCH__,
      TIME_SYSTEM,
      MEAN_ELEMENT_THEORY,
      COMMENT__,
      EPOCH__,
      SEMI_MAJOR_AXIS,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      MEAN_ANOMALY,
      GM,
      MASS,
      SOLAR_RAD_AREA,
      SOLAR_RAD_COEFF,
      DRAG_AREA,
      DRAG_COEFF,
      EPHEMERIS_TYPE,
      CLASSIFICATION_TYPE__,
      NORAD_CAT_ID,
      ELEMENT_SET_NO,
      REV_AT_EPOCH,
      BSTAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      COV_REF_FRAME,
      CX_X,
      CY_X,
      CY_Y,
      CZ_X,
      CZ_Y,
      CZ_Z,
      CX_DOT_X,
      CX_DOT_Y,
      CX_DOT_Z,
      CX_DOT_X_DOT,
      CY_DOT_X,
      CY_DOT_Y,
      CY_DOT_Z,
      CY_DOT_X_DOT,
      CY_DOT_Y_DOT,
      CZ_DOT_X,
      CZ_DOT_Y,
      CZ_DOT_Z,
      CZ_DOT_X_DOT,
      CZ_DOT_Y_DOT,
      CZ_DOT_Z_DOT,
      USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR__,
      USER_DEFINED_EARTH_MODEL__,
      USER_DEFINED_EPOCH_TIMESTAMP,
      USER_DEFINED_MICROSECONDS);
}

struct MPE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MPEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEAN_MOTION = 4,
    VT_ECCENTRICITY = 6,
    VT_INCLINATION = 8,
    VT_RA_OF_ASC_NODE = 10,
    VT_MEAN_ANOMALY = 12,
    VT_NORAD_CAT_ID = 14,
    VT_BSTAR = 16,
    VT_USER_DEFINED_EPOCH_TIMESTAMP = 18
  };
  double MEAN_MOTION() const {
    return GetField<double>(VT_MEAN_MOTION, 0.0);
  }
  bool mutate_MEAN_MOTION(double _MEAN_MOTION) {
    return SetField<double>(VT_MEAN_MOTION, _MEAN_MOTION, 0.0);
  }
  double ECCENTRICITY() const {
    return GetField<double>(VT_ECCENTRICITY, 0.0);
  }
  bool mutate_ECCENTRICITY(double _ECCENTRICITY) {
    return SetField<double>(VT_ECCENTRICITY, _ECCENTRICITY, 0.0);
  }
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  bool mutate_INCLINATION(double _INCLINATION) {
    return SetField<double>(VT_INCLINATION, _INCLINATION, 0.0);
  }
  double RA_OF_ASC_NODE() const {
    return GetField<double>(VT_RA_OF_ASC_NODE, 0.0);
  }
  bool mutate_RA_OF_ASC_NODE(double _RA_OF_ASC_NODE) {
    return SetField<double>(VT_RA_OF_ASC_NODE, _RA_OF_ASC_NODE, 0.0);
  }
  double MEAN_ANOMALY() const {
    return GetField<double>(VT_MEAN_ANOMALY, 0.0);
  }
  bool mutate_MEAN_ANOMALY(double _MEAN_ANOMALY) {
    return SetField<double>(VT_MEAN_ANOMALY, _MEAN_ANOMALY, 0.0);
  }
  uint32_t NORAD_CAT_ID() const {
    return GetField<uint32_t>(VT_NORAD_CAT_ID, 0);
  }
  bool mutate_NORAD_CAT_ID(uint32_t _NORAD_CAT_ID) {
    return SetField<uint32_t>(VT_NORAD_CAT_ID, _NORAD_CAT_ID, 0);
  }
  double BSTAR() const {
    return GetField<double>(VT_BSTAR, 0.0);
  }
  bool mutate_BSTAR(double _BSTAR) {
    return SetField<double>(VT_BSTAR, _BSTAR, 0.0);
  }
  double USER_DEFINED_EPOCH_TIMESTAMP() const {
    return GetField<double>(VT_USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
  }
  bool mutate_USER_DEFINED_EPOCH_TIMESTAMP(double _USER_DEFINED_EPOCH_TIMESTAMP) {
    return SetField<double>(VT_USER_DEFINED_EPOCH_TIMESTAMP, _USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION) &&
           VerifyField<double>(verifier, VT_ECCENTRICITY) &&
           VerifyField<double>(verifier, VT_INCLINATION) &&
           VerifyField<double>(verifier, VT_RA_OF_ASC_NODE) &&
           VerifyField<double>(verifier, VT_MEAN_ANOMALY) &&
           VerifyField<uint32_t>(verifier, VT_NORAD_CAT_ID) &&
           VerifyField<double>(verifier, VT_BSTAR) &&
           VerifyField<double>(verifier, VT_USER_DEFINED_EPOCH_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct MPEBuilder {
  typedef MPE Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MEAN_MOTION(double MEAN_MOTION) {
    fbb_.AddElement<double>(MPE::VT_MEAN_MOTION, MEAN_MOTION, 0.0);
  }
  void add_ECCENTRICITY(double ECCENTRICITY) {
    fbb_.AddElement<double>(MPE::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(MPE::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_RA_OF_ASC_NODE(double RA_OF_ASC_NODE) {
    fbb_.AddElement<double>(MPE::VT_RA_OF_ASC_NODE, RA_OF_ASC_NODE, 0.0);
  }
  void add_MEAN_ANOMALY(double MEAN_ANOMALY) {
    fbb_.AddElement<double>(MPE::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  void add_NORAD_CAT_ID(uint32_t NORAD_CAT_ID) {
    fbb_.AddElement<uint32_t>(MPE::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  void add_BSTAR(double BSTAR) {
    fbb_.AddElement<double>(MPE::VT_BSTAR, BSTAR, 0.0);
  }
  void add_USER_DEFINED_EPOCH_TIMESTAMP(double USER_DEFINED_EPOCH_TIMESTAMP) {
    fbb_.AddElement<double>(MPE::VT_USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
  }
  explicit MPEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MPE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MPE> CreateMPE(
    flatbuffers::FlatBufferBuilder &_fbb,
    double MEAN_MOTION = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RA_OF_ASC_NODE = 0.0,
    double MEAN_ANOMALY = 0.0,
    uint32_t NORAD_CAT_ID = 0,
    double BSTAR = 0.0,
    double USER_DEFINED_EPOCH_TIMESTAMP = 0.0) {
  MPEBuilder builder_(_fbb);
  builder_.add_USER_DEFINED_EPOCH_TIMESTAMP(USER_DEFINED_EPOCH_TIMESTAMP);
  builder_.add_BSTAR(BSTAR);
  builder_.add_MEAN_ANOMALY(MEAN_ANOMALY);
  builder_.add_RA_OF_ASC_NODE(RA_OF_ASC_NODE);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_ECCENTRICITY(ECCENTRICITY);
  builder_.add_MEAN_MOTION(MEAN_MOTION);
  builder_.add_NORAD_CAT_ID(NORAD_CAT_ID);
  return builder_.Finish();
}

struct OMMCOLLECTION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OMMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<OMM>> *RECORDS() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OMM>> *>(VT_RECORDS);
  }
  flatbuffers::Vector<flatbuffers::Offset<OMM>> *mutable_RECORDS() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<OMM>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct OMMCOLLECTIONBuilder {
  typedef OMMCOLLECTION Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RECORDS(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OMM>>> RECORDS) {
    fbb_.AddOffset(OMMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit OMMCOLLECTIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OMMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OMMCOLLECTION>(end);
    return o;
  }
};

inline flatbuffers::Offset<OMMCOLLECTION> CreateOMMCOLLECTION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OMM>>> RECORDS = 0) {
  OMMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline flatbuffers::Offset<OMMCOLLECTION> CreateOMMCOLLECTIONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<OMM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<flatbuffers::Offset<OMM>>(*RECORDS) : 0;
  return CreateOMMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const OMM *GetOMM(const void *buf) {
  return flatbuffers::GetRoot<OMM>(buf);
}

inline const OMM *GetSizePrefixedOMM(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<OMM>(buf);
}

inline OMM *GetMutableOMM(void *buf) {
  return flatbuffers::GetMutableRoot<OMM>(buf);
}

inline bool VerifyOMMBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OMM>(nullptr);
}

inline bool VerifySizePrefixedOMMBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OMM>(nullptr);
}

inline void FinishOMMBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<OMM> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOMMBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<OMM> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_IDLDOCUMENT_H_